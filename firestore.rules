
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper function to check if a user is an admin or owner
    function isPrivileged(userId) {
      return exists(/databases/$(database)/documents/users/$(userId)) &&
             get(/databases/$(database)/documents/users/$(userId)).data.role in ['admin', 'owner'];
    }
    
    // Helper function to check if a user is the owner
    function isOwner(userId) {
      return exists(/databases/$(database)/documents/users/$(userId)) &&
             get(/databases/$(database)/documents/users/$(userId)).data.role == 'owner';
    }

    // Users can read their own profile, admins/owners can read all profiles.
    // Users can only create their own profile document and update their own name/phone.
    // Only the owner can change a user's role.
    match /users/{userId} {
      allow read: if request.auth.uid == userId || isPrivileged(request.auth.uid);
      allow create: if request.auth.uid == userId;
      allow update: if request.auth.uid == userId && 
                       request.resource.data.keys().hasOnly(['name', 'phoneNumber', 'email', 'createdAt', 'role']) &&
                       request.resource.data.role == resource.data.role; // Cannot change own role
      
      // Separate rule for the owner to change other users' roles
      allow update: if isOwner(request.auth.uid) &&
                       request.resource.data.keys().hasOnly(['name', 'phoneNumber', 'email', 'createdAt', 'role']);
    }

    // Allow read access to push subscriptions only for the user themselves.
    // Allow create and delete for the user to manage their own subscriptions.
    match /users/{userId}/pushSubscriptions/{subscriptionId} {
      allow read, create, delete: if request.auth.uid == userId;
    }

    // Shifts can be read by the assigned user or by any privileged user.
    // Shifts can only be created or deleted by a privileged user.
    // Users can update their own shifts (e.g., status), privileged users can update any.
    match /shifts/{shiftId} {
      allow read: if request.auth != null && (resource.data.userId == request.auth.uid || isPrivileged(request.auth.uid));
      allow create, delete: if isPrivileged(request.auth.uid);
      allow update: if request.auth != null && (resource.data.userId == request.auth.uid || isPrivileged(request.auth.uid));
    }
    
    // Any authenticated user can read projects and their files.
    // Only privileged users can create, update or delete projects.
    match /projects/{projectId} {
        allow read: if request.auth != null;
        allow create, update, delete: if isPrivileged(request.auth.uid);
        
        // Files can be created by any authenticated user.
        // Files can be deleted by the uploader or a privileged user.
        match /files/{fileId} {
            allow read: if request.auth != null;
            allow create: if request.auth != null;
            allow delete: if request.auth != null && (resource.data.uploaderId == request.auth.uid || isPrivileged(request.auth.uid));
        }
    }
    
    // Any authenticated user can read announcements.
    // Only privileged users can create or delete them.
    match /announcements/{announcementId} {
      allow read: if request.auth != null;
      allow create, delete: if isPrivileged(request.auth.uid);

      // This is the key rule: Allow an update only if the ONLY field being changed
      // is the 'viewedBy' map, and the user is only adding their own UID to it.
      allow update: if request.auth != null &&
                      request.resource.data.diff(resource.data).affectedKeys()
                        .hasOnly(['viewedBy']) &&
                      request.resource.data.viewedBy.diff(resource.data.viewedBy).affectedKeys()
                        .hasOnly([request.auth.uid]);
    }

    // Settings can only be read and modified by the Owner.
    match /settings/{settingId} {
        allow read, write: if isOwner(request.auth.uid);
    }
  }
}
